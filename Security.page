resources

- <http://www.cs.berkeley.edu/~daw/teaching/cs261-f08/>

people

- michal zalewski: google security person, wrote browsersec book among tons of
  other literature/tools
- jeremiah grossman: prominent web security blogger; leader of whitehat
  security, purveyor of web application firewalls
- theo de raadt: openssl, openbsd
- mark dowd: amazing; ibm x-force team; taossa book; nacl exploits; flash null
  ptr exploit
- mark miller: exploits, reveng, rootkits; joined windows 8/2008
- james whittaker: testing; joined windows 5/2006; joined google 6/2009
- crispin cowan: stackguard, immunix, subdomain, apparmor; joined windows from
  novell 1/2008
- michael howard: windows security team lead
- niels provos: principal engr at google; libevent, libio, openssh privsep;
  malware work

vulnerability databases

- MITRE Common Vulnerabilities and Exposures (CVE)

misc terms

- _side-channel attack_: exploits physical implementation (vs. brute force or theoretical weakness); in crypto
- _covert channel_: channel that draws BW from another channel; in info theory
- _drive-by download_: browser (or extension) exploit triggered on simply
  displaying a page

security models

- clark-wilson integrity model: semi-formal model
  - 2 categories of data, known-good (trusted) and unknown (untrusted)
  - mandatory checks to filter data before moving it from unknown to known-good
  - mandatory checks that data must be in the known-good state before it can
    participate in sensitive ops
  - eg: virus scanner than forces checking of all files as they're opened
- bell-lapuda (BPL) privacy model: formal model and policy
  - "data diode": info only flows in not out; useful for eg CIA
  - label-based access control; formal models of security allow for proofs
  - hugely influential in academic security research
- biba integrity model: dual of BPL model, for integrity instead

high level exploit classification

- confused deputy: fool a privileged process to do things for you
- arbitrary code execution: take over and do things yourself

access control

- _discretionary access control (DAC)_: subjects can xfer perms to others;
  decentralized
  - commonly in practice: objs have owners who controls perms
  - capability systems: subjects can xfer perms to others
- _mandatory access control (MAC)_: policy controlled by admin only; centralized
- _role-based (RBAC)_: restrict system access to authorized users
  - newer alt to MAC/DAC; can sim MAC/DAC
  - users are assigned particular roles; roles are assigned permissions
  - basically, roles are a level of indirection
  - qualitatively/typically, more fine-grained than ACLs, enumerating specific
    high-level operations

integrity control TODO

security

- confidentiality: aka privacy, secrecy
- integrity: eg phishing, MITM, hijacking, forgery
- availability: eg DOS

S/MIME: TODO

- http://en.wikipedia.org/wiki/S/MIME
- http://weblog.infoworld.com/udell/2004/03/23.html

C++

- new/delete[]: if eg you have an array created with new[] and then
  accidentally delete[] a pointer not pointing to the head, then you can
  overwrite in the previous element the mem that delete[] treats as the length
  field
  - gcc: delete[] consults vtable of each object indepdently
  - msvc: delete[] consults vtable of first object only
  - harder on msvc, but can still do interesting things if eg dtor itself does
    anything interesting with the object data, eg free a pointer or set a value
- new[]/delete: you can cause coalescing by setting the `prev` bit in the
  malloc header, among other things

high-level code injection

- unescaped input
- unicode: bad multibyte chars can bypass poor standard-library escaper
  functions unscathed
  - dynamic langs like sql and html/js
  - specific case of parser errors
- parser errors: unhandled cases leading to unesacped input

sandboxing pitfalls

- ptrace: race conditions
  - ptrace behavior: suspends thread; mon reads args (regs, mem) separately
    - monitor can rewrite syscalls
  - multi-threaded arg race (TOCTTOU)
    - A syscalls; monitor checks; B changes args
    - works only on args that are not in regs, eg ptrs to other mem (file paths)
    - heavy-handed soln: prohibit multithreading
    - soln: suspend all threads
      - only for syscalls that use such ptrs ("volatile" syscalls)
      - if block all syscalls, then deadlock
        - devs use syscalls for sync (eg read and write)
        - authors don't know of any such pair of syscalls where one is volatile
  - another process could modify args via shared mem
    - heavy-handed soln: prohibit forking, shared mem
    - soln: or suspend all processes
  - fork-attach race
    - sandbox doesn't immediately attach to a forked child (!)
    - forked child can secretly fork another child monitor won't know about
    - soln: change call from fork to clone; has option to start in ptraced mode
  - FS race: trickiest; use symlinks to break security
    - prisoner does syscall involving path
    - monitor looks up path, following symlinks, to verify
    - another process/thread replaces a component in path with symlink to
      secure region in FS (eg user's $HOME)
    - soln: suspend threads
  - signals TODO
    - avoid by denying signals
  - alts to syscalls
    - lcall7 and lcall27 call gates; removed from most modern linuxes
  - MITRE CVE has over 40 ptrace-related items
  - refs
    - <http://iacoma.cs.uiuc.edu/~greskamp/pdfs/598cz.pdf>
    - NaCl
- chroot
  - TODO
  - (obv) can still make arbitrary syscalls; FS is only one part of sandboxing

web

- flash: `<embed...allowScriptAccess="always">` instead of `"sameDomain"`

low-level exploits

- buffer overflow: return to libc, eg call system("bash")
  - defenses
    - stack canaries: choose random int at process start and insert before
      return addr
      - random xor canaries: xor with the return addr to make sure it's not
        tampered with
      - propolice: gcc's impl; enhanced version of stackguard (never officially
        impl'd in gcc)
      - visual studio: /gs
    - nonexecutable stack: in windows, called Data Execution Prevention
      - NX bit: in page table entries; XD bit in intel, enhanced virus
        protection in amd
      - segments can be readable/writeable/executable, but modern OS's use flat
        memory model (pages instead of segments)
    - address space layout randomization (ASLR): randomize codes, heap, stacks
      - against return-to-libc (arbitrary code can still detect things)
- null pointer exploits: TODO
- heap overflow: overwrite eg a struct's function pointer
- heap spray: give you a place to place executable code, eg if stack is NX or
  your overriding return addr is constrained somehow
  - common in web browser js engines
  - nozzle: msr project that uses sled detection then reduces false positive
    rate with "global heap health metric"
- parser errors: unhandled cases
- format string attacks: eg printf(untrusted_input())
  - eg use %s and %x to print data from stack or other memory locations
  - defenses: statically check format strings
- integer overflow: unexpected number, either negative or large
  - eg size header in messages
  - controls things like strncpy/memcpy for overwrites
  - controls allocations (malloc) for large, unrealizeable mallocs that return
    null
  - also, arithm overflow
- null pointers
  - as write vector: use bad alloc to get ptr = null, where app later does
    *(ptr + offset) = value (where offset and value are user-controlled) to
    write a function ptr (flash exploit)
  - if the ptr is dereferenced and fields are accessed, first prep by writing
    to those fields
- return-to-libc: execute existing code; eg `system`
  - just supply data; no need to inject code, unaffected by NX
  - ASLR defends against this

same-origin policy (SOP)

- policies
  - for DOM access: scripts can access another page's functions/data iff from
    same site (in another frame/window)
    - scripts run in context of includer, not source; can't xhr or DOM-manip
      google
  - for XHR: only time when SOP restrict doc retrieval; html elements can
    source any domain
  - for cookies
  - for flash
    - `crossdomain.xml`: primarily protects access to the host containing the
      `crossdomain.xml`, specified with `allow-access-from`
      - careless wildcard usage opens up holes; eg flickr's api (since isolated
        to a separate domain)
    - can make same-origin HTTP reqs
    - can make same-host TCP conns on any high port
  - for java: applets can only see site it's downloaded from
    - can interact with the embedding page via JSObject API iff `mayscript` set
      in `applet` tag
    - DOMService API allows cross-site embedding pages to be accessed freely!
      with no `mayscript` opt-in, directly contradicting JSObject API
    - ability to send same-origin HTTP reqs using browser stack via
      URLConnection API; can even set `Host` headers or conflicting caching
      directives
    - unconstrained TCP connections back to originating host
  - for silverlight: mimicks flash
- attacks against SOP: XSRF, XSS, DNS rebinding
- rules
  - match: (domain name, app layer protocol (http/ftp), tcp port)
  - opt to communicate by setting `document.domain` to same right-hand fragment
    of current host name (eg en.example.com and fr.example.com set to
    example.com)
  - corollary: all subdomains are implicitly granted accessed to parent domain
- workarounds
  - google analytics works by issuing a single-pixel image request containing
    all collected information
  - google maps api works by dynamically creating script tags that load
    on-demand javascript (data can be in JSON)
  - flash: permits cross-domain requests if allowed by crossdomain.xml on
    target webserver
- threat model: defend against impersonation of user and impersonation of site
- some operations still allowed
  - include scripts across domains
  - submit POST forms across domains
- mitigation practices
  - escaping/filtering
  - input validation
  - http responses are variations
  - http request smuggling

cross-site communication in web apps

- dynamically create script tags to get data; unsafe
- cross-window messaging via `window.postMessage`
  - receiver gets `message` DOM event; msg contains data, domain, uri, source
  - allows cross-site communication
  - requires explicit msg handling on target page, so less susceptible to
    problems than unchecked shared DOM access (pre-SOP)
- IE XDomainRequest
- JSONRequest
  - safer than dynamically creating script tags to get around SOP
  - POST
  - like form.submit, but no auth data or cookies
- W3C CS-XHR
  - w3c access control for cross-origin resource sharing
    - sites specify allowed-origins list in their responses
    - browsers specify origin in their requests; unlike referer, no path
    - <http://dev.w3.org/2006/waf/access-control/>
  - IE team claims this proposal has number of problems
  - <http://blogs.msdn.com/ie/archive/2008/06/23/securing-cross-site-xmlhttprequest.aspx>

web application security

- mozilla content security policy (CSP)
  - no inline scripts, only included script files from whitelisted sites
  - no code from strings: eval, setTimeout-with-string, etc.
  - specify where content allowed from/where requests can be sent
  - see examples on <https://wiki.mozilla.org/Security/CSP/Spec>
- html5 sandboxing
  - sandbox tag treats its contents as different-origin

secure javascript

- caja
- secure ecmascript: <http://ses.json.org/>

javascript

- ESAPI: an encoding lib that uses declarative rules and whitelists of allowed
  chars

XSS (cross-site scripting)

- exploits the trust that a user has for a particular site
- name origins: malicious site loads another site in a frame/window, then use
  js to read/write data; blocked by SOP
- now: code (html/js) injection into pages (eg forum) viewed by others (to
  read/write data)
  - frequently: hijack session key; send by embedding in (eg) img url
- types
  - non-persistent aka reflected: request is instantly and transiently used
    (not stored) to return result, eg search engine box
    - only affects the requester, but social engineering (eg send link)
    - most common, but importance is arguable (due to soc eng requirement)
  - persistent aka stored aka second-order: request is stored & later
    displayed (to others)
  - DOM-based aka local: TODO
    - orthogonal to persistence
- 80% of all sec vulns in 2007 -symantec

XSRF (cross-site request forgery)

- exploits the trust that a site has for a particular user
- before SOP, easy for evil.com to use XHRs to send requests to bank.com that
  carry cookies and auth data
- make user's browser send request to a site that user has active credentials
  on
- examples
  - malicious site contains form that entices user to submit
    - POSTs to bank site withdrawing money
    - requires user to be authenticated
  - post img to bank site forum whose src is a GET that (eg) withdraws money
- fixes
  - referer checking: subject to SOP implementation vulnerabilities,
    referer-filtering
  - use eg nonces: more complex

- PEM: privacy-enhanced mail; a format of base64-encoded DEM certificates
  between "-----BEGIN CERTIFICATE-----" and "-----END CERTIFICATE-----"

- PKI: pub keys, certs, and all that

- MAC: integrity and authenticity; TODO
- HMAC: hashed MAC; TODO
- cryptographic hash functions: TODO
- diffie-hellman: TODO

network attacks

- sockstress: syn-synack-ack flood (local iptables configured to not be
  affected)
- ping of death: icmp packet that's >64KB in length
- teardrop: mangled IP fragments with overlapping, over-sized payloads

network hijacking

- TCP hijacking
  - if on same segment: easy to just observe seqno and spoof it
  - if on diff segment: need to guess initial seqno
- IP/BGP/prefix hijacking: take over groups of IPs by corrupting Internet
  routing tables
  - announce a prefix that it you don't actually own
  - announce a more specific prefix than the true owner's prefix
  - announce that you have a shorter route to the target AS
  - "black holing": ??
  - must hijack BGP TCP session
- DNS cache poisoning: tricking NS into thinking it got authentic info
  - specify attacker's choosing of authority NS for either requested domain or
    unrelated domains
  - bugs in eg BIND allowed the above to slip by; now fixed
  - still, no signing means easy to do MITM
  - DNSSEC signs responses with PKI
- DNS rebinding: TODO
  - attacker gets user to use his DNS server
  - attacker's DNS server first maps bank.com to attacker's IP, then maps
    bank.com to bank.com's IP
  - attacker's code loaded in first request can send request to second IP
  - user-agent must be able to notice the changed IP

brute-force DOS

- flooding
- DDOS
- easy to detect (? TODO)

sophisticated DOS

- app bugs: eg buffer overflows
- fragmentation of data structures: eg hash tables
- algorithm worst cases, eg regexes

public key crypto

- rsa
- dsa
- elliptic curve
  - attractive for mobile/wireless env's
  - vs RSA: equiv security with smaller key sizes (faster, less resources)

block ciphers vs. stream ciphers

- distinction not always clear cut; block ciphers sometimes act effectively as
  stream ciphers
- stream ciphers usu. faster, but serious sec problems if used incorrectly
  (esp: same starting state must never be reused)

stream ciphers

- _stream cipher_: symmetric key cypher where plaintext is combined with
  pseudorandom cipher bit stream called _keystream_, typically xor
  - plaintext bits encrypted one at a time
  - xform varies during encryption
- rc4: by ron rivest; in (eg) WEP, WPA (default), TLS/SSL (opt), BT, ssh (opt),
  RDP, KRB (opt), PDF

block ciphers

- _block cipher_: operate on large blocks of digits with a fixed, unvarying
  xformation
  - eg 128-bit blocks of plaintext -> 128-bit blocks of ciphertext
- des: early highly influential; ibm; 1997; insecure to brute force
  - EFF DES cracker aka "deep crack": cracking machine
  - with distributed.net, decryted challenge 3 after just 22h
- 3des: 1998; applies des 3x per block; used by electronic payments industry
  - simply increases key size 3x to defend against brute force
  - pseudocde: des_enc(k1) -> des_dec(k2) -> des_enc(k3)
- blowfish: bruce schneier; 1993; fast; no known cryptanalysis; widely used,
  but aes overshadows it
- aes: successor to des; 2001
  - 128, 192, 256 bit key sizes; all 128 bit block sizes

windows

- ASLR
- DEP: uses NX if avail or software emulation with limited, almost-unrelated
  protection with SafeSEH (simply checks that an exception is registered in a
  function table for the app)
- common exploit techniques TODO <http://www.hick.org/~mmiller/shellcode/win32/generic.c>
  - PEB
  - SEH
- steadystate/pc safeguard
  - applied only to std accounts; rolls back all reg, fs changes

windows 7 UAC design flaws

- auto-elevating executables: to reduce annoyance
  - but anyone can run them; at one pt rundll32 was auto-elevating
- auto-elevating components
  - work only when caller is ms-signed exe, eg explorer
  - but procs can inject code into ea other as long as same user
- <http://arstechnica.com/microsoft/news/2009/03/opinion-ms-should-kill-win7-uac.ars>

selinux (nsa 2000; merged mainline 2003)

- supplements unix DAC with MAC
- selinux is an implementation of FLASK for linux
- hybrid of concepts and capabilities from MAC, MIC, RBAC
- hard to config
- applies labels to files
- identifies files by inodes
- perms
  - specify specific ops (creat, rename, unlink, etc)
  - allow, deny, auditallow, auditdeny

linux apparmor (novell 2005)

- supplements unix DAC with MAC
- manually specify profiles for apps
- "learning mode" logs holes that are opened and creates profiles from that
- alternative to selinux
  - identifies files by paths instead of inodes
  - can make use of FSs with no support for extended file attributes, eg NFS

SFI
---

TODO

SFI (robert wahbe, SOSP 1993)

- RISC

pittsfield (stephen mccamant, greg morrisett, TR/usenix 2005)

- SF vs pittsfield: write/jump sandboxing vs full read/write/jump isolation

vx32 (bryan ford, russ cox, TR 2008)

- x86, linux/freebsd

engineering
-----------

<http://www.matasano.com/log/989/thoughts-on-ten-years-of-qmail-security/> (DJB 2007)

- directions of progress
  - eliminating bugs
  - eliminating code
  - eliminating trusted code
  - distractions
    - chasing attackers
    - minimizing privilege: vs minimizing TCB
      - ["privileges" here are superficial OS level privileges]
    - speed
- eliminating bugs
  - enforcing explicit data flow: process isolation, PL support
  - simplifying integer semantics: used big num lib, PL support
  - avoid parsing: anything with strings; quoting; printf bugs
  - generalizing from errors to inputs: insert testable abstractions
- eliminating code
  - identifying common functions
  - automatically handling temporary errors [exceptions better than error checking]
  - reusing network tools [like `inetd`]
  - reusing access controls: eg assuming a user's uid
  - reusing the file system: as an associative array (instead of parsing a
    single config file)
- eliminating trusted code
  - accurately measuring the TCB: hard
  - isolating single-source xforms
    - eg jpegtopnm: after jailing, attacker can only produce any img he wants,
      but he could've done this in the first place
  - delaying multi-source merges (like XSS)

web
---

robust defenses for CSRF (adam barth, collin jackson, john c mitchell, CCS 2008)

- login CSRF
- 

DOS
---

<http://www.checkmarx.com/NewsDetails.aspx?id=23> regex ("redos")

- worst-case exponential
- eg: /^(a+)+$/ on "aaaaX" produces 16 paths
- more: /([a-zA-Z]+)*/, /(a|aa)+/, /(a|a?)+/, /(.*a){x}/ for x>10
- many legit bad regexes even in OWASP validation regex repo
- many pts of attack; regexes are ubiq
  - submit a bad regex or leverage regex injection
  - submit a string for an already-there bad regex
- meta-regex for finding bad regexes; use codesearch to find
- browsers protect against infinite loops but not bad regexes
- should be not-too-bad to statically analyze regexes

fun exploits
------------

morris worm

mark dowd flash exploit 2007

- <http://chargen.matasano.com/chargen/2007/7/3/this-new-vulnerability-dowds-inhuman-flash-exploit.html;jsessionid=8DDE25A54184976447838948127BE85C.web18>
- bounds-checker treats field as signed, permitting (small?) negative numbers
- interpreter treats as unsigned, so neg -> large
- controls alloc, so bad alloc -> null ptr
- flash uses that ptr + attacker-controlled offset
- to that addr, flash writes attacker-controlled value
- idea: use this writing vector to target a function ptr, changing it to a
  user-supplied buffer of shellcode
- tough constraints: offset > 0x80000000, offset + 4 divisible by 12, used
  value = (value cast from 16- to 32-bit) - some other var
- so instead, manipulate actionscript bytecode state
- interpretation differs btwn verifier TOC & executive TOU
  - verifier ignores undefined bytecodes
  - verifier keeps table defining bytecode instruction lengths
  - bytecode length table is valid target of null ptr overwrite
  - executive has totally diff machinery for interpreting bytecode
- use null ptr write vector to clobber the right value in length table, and you
  can make unused instr that the verifier ignores seem much longer than it is
- executive doesn't ignore what comes after the initial unused instr, so put
  valid bytecode there for execution

kernel null pointer exploits

- tun driver uses null ptr; can write to 0x0 with mmap, iff selinux is on,
  ironically
- ptr is used in an exploitable way
- "In well-designed systems, catastrophic failures are rarely the result of a
  single failure. That is certainly the case here."
- <http://lwn.net/Articles/342330/>

DIFC
----

flume

- IFC goals
  - secrecy: prevent leaking private data
  - integrity: prevent accepting untrusted data
- DIFC: decentralized means no central deputy needed for declassification
- flume: DIFC at process granularity, controlling IO; user-level monitor
- related work
  - jif: finer-grained control at function granularity; requires app rewrite
  - asbestos/histar: kernels designed to support DIFC; message granularity
  - flume
    - rules inspired by jif
    - labels influenced by asbestos
    - adopted histar's requirement that threads must explicitly request label changes
- concepts
  - a tag $t$ is associated with some category of secrecy or integrity
  - labels are sets of tags
  - a process $p$ has 2 labels, $S_p$ for secrecy and $I_p$ for integrity
    - if $t \in S_p$ then (conservatively) $p$ saw private data tagged with $t$
    - if $t \in I_p$ then every input to $p$ has been endorsed as having
      integrity for $t$
  - two capabilities per tag
    - $t+$: ability to add $t$ to one of its label
    - $t-$: ability to remove $t$ from one of its label
    - note: you might not want to use the same $t$ for both secrecy and
      integrity; see examples below
  - each $p$ owns a set of capabilities $O_p$
  - $D_p = { t \vert t+ \in O_p, t- \in O_p }$ (the set of tags for which $p$
    has dual privileges)
  - any $p$ can create tags; added to $D_p$
  - global capability set $O \subseteq O_p \forall p$
- export protection example
  - if $b \in S_p$ then $p$ can write to $q$ iff $b \in S_q$ also
  - but _any_ process can add $b$ and read secret $b$ since $b+ \in O$
    - means all their output will be tagged with $b$
    - note that this means $b$ should not be used for integrity, or anyone can
      add it to their integrity label
  - but a process $p$ can't leak it out of system unless $b- \in O_p$
    - transition: from secret to non-secret
- integrity protection example
  - if $b \in I_p$ then $p$ can read from $q$ iff $b \in I_q$ also
  - processes cannot willy nilly add $b$ and be trusted to provide $b$-tagged
    data
    - transition: from non-trusted to trusted
    - this is called _endorsement_
  - can, however, remove $b$ to remove trust (not sure why they want to do
    that); so $b- \in O$

IE

- Protected Mode for isolation and sandboxing
- type 1 (reflected) xss filter

malware
-------

the ghost in the browser: analysis of web-based malware (provos, google, 2008)

- 10% of URLs engaged in drive-by downloads
  - map-reduce looks for known malicious URLs in corpus
  - instrumented IE in VM; watch for add'l processes, changes in FS/reg
- malware comes from lack of content control on pages
  - web app exploits
  - user content
  - ads: partner with dedicated ad companies, not individual advertisers; trust
    is not transitive
  - third-party widgets: eg stats counter, iframemoney.org
- exploits
  - popular: MS DAC
    - js instantiates activex object; normally not safe for scripting
    - js retrieves exe via XHR
    - adodb.stream used to write exe to disk
    - shell.application launches new exe
  - popular: MS WebViewFolderIcon heap spray
  - many gather info (eg browser, jvm version, OS patches) then fetches
    applicable exploits
  - can also trick user, eg video activex codec
- trends
  - js escaping: effective against signature/anomaly-based IDSs; also used by
    legit sites
  - classification: use majority voting by major AV software
    - trojan: contains/installs malicious app with harmful impact on user's
      computer
      - most common: downloaders (get other trojans), banking (bank acct
        numbers, passwds)
    - adware
    - unknown/obfuscated
  - http reqs not from browser: mostly for popup ads, some for updates/instrs
  - most exploits not hosted on compromised sites; distributed across many
    sites
  - hosted binaries mostly change infrequently; some do, to evade sig scans
- most malware are user-mode apps
- [curiously, saw nothing on spam]

a crawler-based study of spyware on the web (uw, 2007)

- downloaded exe's, ran/install in VM, ID with lavasoft ad-aware
- twice: 5/2005, 10/2005
- high risk sites: games, celebs
- types
  - adware
  - keylogging spyware
  - trojan downloaders
  - browser hijackers: search engine, default home page, URL redirection
  - dialers: uses modem to call expensive toll numbers
  - mostly adware, hijackers (relatively benign) but many downloaders
  - drive-by's have same distribution as spyware
- time comparisons: older AV DB misses 1/3 of spyware; URL blacklisting
  ineffective [numbers don't seem to support, though]
- many tweak registry
- collection via disposable webmail
- [notes]
  - curiously, saw nothing on spam, game passwd harvesting
  - no need for exploits

systems security
----------------

return-oriented programming (Hovav Shacham, ucsd, 2009)

- generalization of return-to-libc; chain `ret`s together
- [not much here]

seminal
-------

Why Isn't Trust Transitive? (bruce christianson, william s harbison)

- straightforward but classic

Sandboxing
----------

privsep (niels provos, usenix 03)

- privileged parent monitor and unprivileged child process
- no syscall tracing; only using OS UID-based privilege separation
- child runs with unused user and chroot'd to /var/empty
- comm over pipes, shared mem

Efficient Software-Based Fault Isolation (Wahbe, sosp93)

- can isolate via separate addr spaces, but switches not good for tightly
  coupled modules
  - RPC: trap, copy, ctx save/restore, switch HW addr space (flush TLB), trap
    - repeat on return; 3 OOM > normal proc call
  - eg postgres extensible type system can define ctors, dtors, preds
  - eg OS exts: packet filters, app-specific virt mem mgmt, Active Messages
- propose a portable, PL-indep approach:
  - load code/data into own _fault domain_ (portion of host's addr space)
  - rewrite code to prevent writes/jumps outside fault domain
- poses tradeoff rel. to hardware fault isolation: substantially faster comm
  btwn fault domains, but slightly increased execution time for distrusted
  modules
  - evaluated on postgres; 3x faster than sep addr spaces

App-V (john sheehan, MS ECS 2009)

- _sequencing_: process of packaging apps
  - monitor installation from kernel; capture FS/reg changes
  - now know all the resources needed by app; can optimize the layout for
    streaming
  - extract metadata; eg recognize COM objs, NT services; store in manifest
  - heuristics
    - program files: don't need to roam with user
    - hkey_current_user keys: should roam with users
    - UI for tweaking these settings
- SystemGuard: "namespace mgr"
  - system namespace: fall-through for everything else
  - elseapp namespace: produced by sequencing
    - eg `C:\windows\system32\foo.dll` could've been installed by app
    - enables streaming (Click2Run), user roaming
  - modification namespace: where writes go (either roaming or non-roaming)
  - handles: files, reg, COM, fonts, services, object mgr, mailslots, etc.
    - eg virtualize CLSIDs for COMs; virtualize service names
    - don't deal with drivers; typically installed as part of platform
  - dynamic, not static: watch processes, not programs
    - eg cmd is already there, but if run via a VS shortcut, run it in the VS
      bubble
  - for cross-app, dynamic suite composition (DSC) feature: run in same bubble
- office doesn't user the generic app-v UIs

native client

- inner sandbox
  - software fault isolation
    - in general disassembly is unreliable: same instruction stream may be
      entirely different if you jump to somewhere in the middle of it
    - goal: get reliable disassembly; then, can prohibit certain instructions
    - static validation of most calls/jumps
    - once loaded, binary is not writable; also uses x86 segments to constrain
      the executable instruction range
    - locates instructions at address 0 so that indirect jumps need only be
      prefixed by an `and` and not an `and;or`
    - omit certain instructions: ret, int, syscall; use indirect jumps
    - all indirect branch targets must be aligned; bitmask every target
      address
    - no code gen, mixed text/data, overlapping instrs
  - x86 segments: hardware support -> faster
    - original SFI: bitmask every load/store address
    - caveat: need LDT; privileged instruction, vista 64 doesn't provide this;
      confuses os an hardware exceptions
- outer sandbox
  - redundant; defense in depth
  - system call filter for untrusted modules
  - OS-dependent: ptrace on linux, syscall ACLs on Windows
    - to avoid ptrace overhead, nacl provides own shared mem and sync objects
- compile for native client with modified gcc (1000 lines patched)

Sprockets: Safe extensions for distributed file systems (umich usenix 07)

- for distributed FS "tweak" extensions; DFSs mostly impl'd in user space
  - run procedure in same addr space, then always roll back except for the
    buffer expecting results (this is validated/acted on by host)
  - programmability like proc call: lightweight usage, can access any data/code
  - cost: not up front per sprocket, but per line of code executed, since
    sprockets are small
- alt designs and their problems
  - direct procedure call: same addr space
  - separate addr spaces, eg fastcgi
    - no access to (reuse of) data/code; need to define (read) interface
    - requires OS fine-grained sandboxing (only read file1 and write file2)
  - chkpt/rollback (fork): closest to sprockets
    - heavy; still requires OS sandboxing
    - idea for multithreading: wait for all locks to release before fork
- binary instrumentation/SFI with PIN
  - first save caller ctx (regs, PC, heap size, etc)
  - for each mem write, save orig loc/val in undo log
  - dynamically enable/disable instrumentation: core FS functions called via
    sprockets are instrumented; outside, orig is used
  - OOM slower, but faster than fork
  - optims: no need to restore unused memory, eg space below stack or malloc'd
    by sprocket; avoid dup backups
- handling buggy sprockets
  - register sig handlers for segfaults, timeouts
  - instrument syscalls with check against whitelist + optional specific
    syscall handling (eg closing an fd that it didn't open)
- multithreading: sprocket time (.14-.62ms) << scheduling quantum
- implemented: transducers (id3), app-specific resolution (id3), devices (PTP)
- related work
  - wahbe: limits access to addr space outside sandbox
  - vino: SFI for OS exts; not full access (whitelist of kernel fn's)
  - nooks: used this technique for device drivers
  - exokernel: allows user-level code to impl many services
  - sprockets target functionality already avail. at user-level; min changes;
    user-level tools/libs
  - type-safe langs: eg SPIN OS uses modula-3; limits FS code reuse (mostly not
    in type-safe langs)
  - watchdogs, stackable FSs: more coarse-grained ext interface allowing exts
    only at certain pre-defined VFS ops like open, close, write
  - may leverage STM/HTM techniques

Saltzer & Schroeder, "The Protection of Information in Computer Systems"

- seminal paper on OS security
- no mention of pub key crypto; still 5 yrs away

chrome/chromium

- chroot: requires suid but is ironically more secure
- exec()ing from empty jail is hard
  - can copy all dep files, but maintenance/packaging nightmare
  - use clone() flag CLONE_FS and share FS struct btwn a trusted/privileged
    thread and the exec()ed renderer
  - trusted thread can call chroot and have it affect the unprivileged,
    untrusted renderer post-exec
- CLONE_NEWPID and CLONE_NEWNET: prevent sending signals, network access
- <http://scarybeastsecurity.blogspot.com/2009/10/chromium-and-linux-sandboxing.html>

Security In-Depth for Linux Software: Preventing and Mitigating Security Bugs (Julien Tinnes, Chris Evans, Google, Hack in the Box 10/2009)

- examples: chromium, vsftpd
- security in depth
  - reduce bugs
  - app-level mitigation (SSP, relro)
  - sys-level mitigation (ASLR, NX)
  - privilege dropping (sandboxing)
  - mandatory access control (MAC)
  - update strategy
- privileges in linux: processes and privileges
  - kernel is a mandatory interface to system; process is privilege boundary
  - A > B if A's privileges are superset of B's
  - procs have uid + gid
  - threads *generally* don't have privilege separation (but: clone, seccomp)
  - if A can ptrace B, then A > B
  - uids/gids
    - types
      - real: owner; who you really are; only root (usu. login) can change; `id -ru`
      - effective: for access ctl; `id -un`
      - saved: 
      - FS: file system; in linux
    - operations
      - fork inherits UIDs
      - suid + seteuid let you temporarily drop root and restore later
      - not sure if correct (prolly not):
        - `setuid(x) = if (euid == 0) { ruid = euid = suid = x } else { euid = x }`
        - `seteuid(x) = if (euid == 0) { ruid = euid = suid = x } else { euid = x }`
    - summary
      - (r)uid, euid, suid, fsuid
      - (r)gid, egid, sgid, fsgid, supplementary groups
  - POSIX.1e capabilities: for splitting root privileges; in linux 2.2
  - partial uid switching
    - mostly useful to avoid confused deputy problems
    - useless given arbitrary code execution
    - only root can use
  - linux capabilities
    - CAP_NET_RAW: permit use of RAW and PACKET sockets
    - CAP_SYS_ADMIN: administrative ops (mount, sethostname, etc)
    - CAP_NET_BIND_SERVICE: binding to reserved ports (<1024)
  - common mistakes
    - forgetting to switch from uid 0
  - chroot: popular way to drop FS access; root only
    - requires dropping privileges afterward, or easy to escape
    - re-chroot technique (popular), inject modules, ptrace non-chroot-ed proc,
      etc
    - look at capabilities for inspirations of other things you can do as root
      to escape
  - recent kernels add clone/unshare flags for dropping privileges; root only
    - CLONE_NEWPID: new pid namespace
    - CLONE_NEWNET: new network namespace
    - CLONE_NEWIPC, CLONE_NEWUTS, CLONE_NEWNS
  - resource limits
    - RLIMIT_NOFILE: can't get new fd's, but can still rename and unlink
    - RLIMIT_NPROC: can't create new procs
    - if used for security, both soft and hard limit need to be set to 0
    - or attacker could replace existing fd to create new fd's
  - linux supports per process dumpable (debuggable) flag
    - can be set through
      - prctl with PR_SET_DUMPABLE
      - when executing a file you don't own and can't read
      - when switching uid
    - CAP_SYS_PTRACE: can't ptrace a non dumpable proc; thus, elevation of
      privileges
    - allows to lower another process' privileges
- writing good code
  - preventing common security flaws
  - privilege separation
  - trust relationships
  - update strategy
- sandbox designs
  - ptrace
  - setuid
  - SECCOMP
  - other
  - attack surface eval

Xax (MSR)

- mechanisms
  - picoprocess: native-code execution abstraction that is secured via hardware
    memory isolation and a narrow syscall interface, akin to streamlined
    hardware VM
  - PAL: provides an OS-indep ABI to xax picoprocesses
  - hooks to existing browser mechanisms to provide aps with system services
    (network, UI, storage) that respect browser security policies
  - lightweight modifications to existing tool chains and code bases for
    retargeting legacy code to the xax picoprocess env
- goals and alternatives
  - goals: security, OS indep, perf, and legacy support
    - [they compare SF LOC of C/C++ vs. others; this disregards verbosity, the
      projects themselves, etc.; may have been better to count number of
      projects]
  - alternatives
    - existing web-app mechanisms
      - js: slow; no legacy code
      - activex: no sandboxing; only a way to package app for invoking via web;
        windows only
      - IL (flash/java/MSIL): no legacy code
    - OS processes: not OS indep, insufficient sec
      - can write interposing confinement layers, but that's hard
      - xax goes opposite: start with no interface and add
    - hardware vm's: big/complex, so slow dl, insecure, hard to write
      - xax = extreme paravirt where guest os is removed
      - reduces vmm also: no emulation of devices, mmu, cpu kernel mode
- mechanisms
  - picoprocess: VM without devices, MMU, CPU kernel mode
    - alternatively, a highly restricted proc prevented from making kernel calls
    - hardware-memory-isolated address space; strictly user-mode CPU
    - xax monitor: browser plugin; picoprocess makes xaxcalls to this
    - xaxcalls vary slightly among platforms to keep xax monitor simple
  - platform abstraction layer (PAL) for OS indep
    - PAL translates OS-indep ABI to OS-specific xaxcalls
    - PAL runs inside picoprocess; untrusted; everything above ABI is remote
    - only 9 calls in xax abi
    - simple shim libxax that converts app dev toolchain's calling convention
      into xax ABI calls into PAL
  - services via browser mechanisms: same security policies
    - picoprocess is web server; serves http requests
  - lightweight code modification: 5 steps to addressing all porting issues
    - TODO
    - obliviously failing
    - emulate syscall functionality internally
      - eg fs: read from tar, write to ramdisk; also read from other files, eg
        downloaded from server
    - provide real syscall functionality via xaxcalls
      - real backing functionality for remaining 137 syscalls (11 unique)
- implementation
  - monitor, boot block, PAL
    - monitor is its own process; xaxcalls via shared mem
    - boot block sets up shared mem, makes kernel call to revoke ability to make subsequent kernel calls, and continues into PAL (which loads/executes app)
    - most xaxcalls implemented straightforwardly in similar way on both platforms
  - linux: uses ptrace to intercept entry/exit of every syscall and xfer control to monitor
    - monitor replaces syscall with effectless getpid
    - syscalls also used by pal to signal a xaxcall; monitor checks if shared memory contains legit xaxcall id/args
    - for alloc/free, replace syscall with mmap; this is because monitor can't alloc mem on behalf of child
    - 3 syscalls (slow); also if monitor crashes then child can make syscalls
      - fix by using kernel module
  - windows: custom kernel module xaxdrv
    - each windows thread has pointer to table of syscall handlers; xaxdrv replaces this
      - in replacement table, if caller is kernel mode, then pass through preserving dispatcher's stack frame; else, xaxcall
    - monitor can alloc/free on behalf of child
    - easy to port to many windows; just change some pointer values
    - could also have patched every entry in std syscall table, but discouraged since it affects every process i the system
  - loaders: have elf and pe-coff loaders
  - browser integration: local server appears as same origin; most URL requests go through to host but `/_xax/` refers to existing/new picoprocess
- examples
  - headline reader (audio) and 3D demo (10 fps) shows we can deliver rich content
  - social network visualizer shows utility of leveraging existing graphviz legacy code
  - ghostscript (pdf) and kaffe (jvm) shows this can replace browser plugins
- evaluation
  - performance: high xaxcall overhead; fast(er) as java; much faster than v8
  - legacy: apps use 15 libs totaling 3.3M loc in 4 langs with minimal changes
  - os-indep: linux & many windows
  - security: trusted code base (TCB) less tha jvm/flash
- related work
  - TODO
- limitations
  - threading: need a new xaxcall for spawing & asynchronous signaling
  - porting more mainstream C libs like glibc/MS is harder since they rely on
    x86 segment registers to manage thread-local storage, which can't be
    assigned in user mode, so must emulate or obviate this functionality
  - port more interactive code: GUI libs with few deps (qt/embeded); blit frame
    buffers; keyboard/mouse events catpure in js

umview

- linux sandboxing tool; uses ptrace
- tried contributing some kernel patches for ptrace perf (pmulti)
